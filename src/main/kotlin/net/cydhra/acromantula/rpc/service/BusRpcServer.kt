 package net.cydhra.acromantula.rpc.service

import com.google.protobuf.Empty
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.cancel
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.runBlocking
import net.cydhra.acromantula.bus.EventBroker
import net.cydhra.acromantula.bus.events.ApplicationShutdownEvent
import net.cydhra.acromantula.bus.events.ApplicationStartupEvent
import net.cydhra.acromantula.proto.*

class BusRpcServer : BusServiceGrpcKt.BusServiceCoroutineImplBase() {

    @ExperimentalCoroutinesApi
    override fun getEventStream(request: Empty): Flow<Bus.Event> {
        // the callback flow internally uses a buffered channel to use store the events generated by the registered
        // listeners until the client consumes them. If the client stops consuming them without closing the flow,
        // the channel will eventually block indefinitely and thus create a resource leak, as more and more
        // coroutines in the EventBroker suspend and never wake up. However, since the coroutines suspend without
        // blocking the thread, the EventBroker should retain functionality.
        return callbackFlow {
            val applicationStartupListener: suspend (ApplicationStartupEvent) -> Unit = {
                offer(bus_Event {
                    this.startupEvent = bus_ApplicationStartUpEvent {}
                })
            }

            val applicationShutdownListener: suspend (ApplicationShutdownEvent) -> Unit = {
                offer(bus_Event {
                    this.shutdownEvent = bus_ApplicationShutdownEvent {}
                })
                this.cancel("graceful shutdown")
            }

            EventBroker.registerEventListener(ApplicationStartupEvent::class, applicationStartupListener)
            EventBroker.registerEventListener(ApplicationShutdownEvent::class, applicationShutdownListener)

            awaitClose {
                // unregister the listeners of this flow, if the flow is closed (most likely by the client)
                runBlocking {
                    EventBroker.unregisterEventListener(ApplicationStartupEvent::class, applicationStartupListener)
                    EventBroker.unregisterEventListener(ApplicationShutdownEvent::class, applicationShutdownListener)
                }
            }
        }
    }
}